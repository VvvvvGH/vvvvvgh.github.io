import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,b as p,o as n}from"./app-CJlMl9Ja.js";const r={};function i(o,t){return n(),e("div",null,t[0]||(t[0]=[p('<p>Quick start: https://langchain-ai.github.io/langgraph/tutorials/introduction/</p><p><strong>什么是智能体</strong>？ 当我们谈论系统是&quot;智能体&quot;时，我们指的是使用大型语言模型（LLM）来决定控制流的系统。LLM 可以在不同层次上决定控制流，例如LLM在两个流程之间进行路由、LLM决定调用哪个工具、LLM决定是否输出最终答案等。</p><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p><strong>什么是智能体</strong>？</p><p>还有其他一些通常与智能体相关的概念</p><ul><li>工具调用：这通常是 LLM 做出决策的方式</li><li>行动执行：通常情况下，LLM 的输出被用作行动的输入</li><li>记忆：可靠的系统需要了解发生的事情</li><li>规划：规划步骤（无论是显式还是隐式）帮助 LLM 以最高质量完成任务</li></ul><p><strong>什么是 langgraph ？</strong></p><p>LangGraph 是一个库，用于构建有状态的多参与者应用程序，利用大型语言模型（LLM）来创建智能体和多智能体工作流。与其他 LLM 框架相比，它具有以下核心优势：循环、可控性和持久性。</p><p>LangGraph 允许定义包含循环的流程，这对于大多数智能体架构至关重要，使其区别于基于有向无环图（DAG）的解决方案。作为一个非常底层的框架，它提供了对应用程序流程和状态的细粒度控制，这对于创建可靠的智能体至关重要。此外，LangGraph 内置持久性，支持高级的人类在环和记忆功能。</p><ol><li><strong>循环和分支</strong>： 在应用程序中实现循环和条件语句。 <img src="https://cdn.vistazx1.top/images/202409290951953.webp" alt="Pasted image 20240723143000"></li><li><strong>持久性</strong>： 在图的每一步自动保存状态，支持在任何点暂停和恢复图的执行，以实现错误恢复、人类介入工作流、状态回溯等功能。</li><li><strong>人机协作</strong>： 人可以中断图的执行，并且批准或编辑智能体的所有动作计划。</li><li><strong>流式支持</strong>： 在每个节点生成输出时进行流式传输，包括令牌流式传输。</li><li><strong>与 LangChain 的集成</strong>： LangGraph 可以无缝集成 LangChain 和 LangSmith</li></ol><p><strong>LangGraph核心概念：</strong></p><ol><li><p><strong>高度可控</strong>： 跟LangChain相比，LangGraph 是一个非常底层的系统，这赋予了用户对所构建系统的高度控制能力。目前让智能体系统可靠地工作是一个挑战，用户对系统控制得越多，任务完成的效果就更好。</p></li><li><p><strong>人机协作</strong>： LangGraph 内置了一个持久层，这使得人机协作的交互模式成为可能。我们相信，&quot;人类-智能体交互&quot;模式将成为新的&quot;人机交互&quot;，因此我们在设计 LangGraph 时内置了持久性以支持这一点。</p></li><li><p><strong>流式优先</strong>： LangGraph 对流式处理提供了一流的支持。智能体应用程序通常需要较长时间运行，因此向同步进度非常重要，而流式处理是实现这一点的绝佳方式。LangGraph 支持事件（如工具调用）和 LLM 响应的流式传输。</p></li></ol><h2 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式"><span><strong>设计模式</strong></span></a></h2><h3 id="结构化输出" tabindex="-1"><a class="header-anchor" href="#结构化输出"><span>结构化输出</span></a></h3><p>在构建智能体时，通常希望节点内的LLM（大语言模型）返回结构化输出。因为结构化输出可以用于图的路由下一步（例如，在两个不同的状态之间流转）或更新状态的特定字段。由于LangGraph节点可以是任意的Python函数，因此你可以随意实现这一点。</p><h3 id="工具调用" tabindex="-1"><a class="header-anchor" href="#工具调用"><span>工具调用</span></a></h3><p>在智能体中，工具调用是普遍使用的。工具调用指的是从多个可用工具中选择，并指定要调用哪些工具以及输入应该是什么。由于LangGraph节点可以是任意的Python函数，因此你可以随意实现这一点。</p><h3 id="记忆" tabindex="-1"><a class="header-anchor" href="#记忆"><span>记忆</span></a></h3><p>记忆是智能体应用中的一个关键概念。记忆很重要，因为终端用户通常期望应用程序能够上下文。LangGraph非常适合让你完全控制应用程序的记忆。通过用户定义的State，你可以指定要保留的记忆的方式。通过检查点，你可以存储之前交互的时间点，并在后续交互中从那里恢复</p><h3 id="人类在环" tabindex="-1"><a class="header-anchor" href="#人类在环"><span>人类在环</span></a></h3><p>智能体系统通常需要一些人类在环（或&quot;在环&quot;）的交互模式。这是因为智能体系统仍然不太可靠，因此在任何敏感任务/操作中都需要有人类参与。由于检查点的存在，这些在LangGraph中都很容易实现。检查点之所以必要，是因为许多这些交互模式涉及运行图直到某个点，等待某种人类反馈，然后继续。当你想要&quot;继续&quot;时，你需要访问图在中断之前的状态，而检查点是一个内置的、非常方便的方式来实现这一点。</p><p>我们看到一些常见的人类在环交互模式正在出现： <img src="https://cdn.vistazx1.top/images/202409290951915.webp" alt="Pasted image 20240802114103"></p><h4 id="审批" tabindex="-1"><a class="header-anchor" href="#审批"><span>审批</span></a></h4><p>一个基本的模式是让智能体在执行某些工具之前等待审批。这可能是所有工具，或者只是某些工具的子集。对于更敏感的操作（如写入数据库），通常建议这样做。这可以通过在特定节点之前设置断点来轻松实现。请参阅本指南，了解如何在LangGraph中实现这一点。</p><h4 id="等待输入" tabindex="-1"><a class="header-anchor" href="#等待输入"><span>等待输入</span></a></h4><p>类似的模式是让智能体等待人类输入。这可以通过以下步骤实现：</p><ol><li>创建一个专门用于人类输入的节点</li><li>在节点之前添加断点</li><li>获取用户输入</li><li>使用该用户输入更新状态，作为该节点</li><li>恢复执行</li></ol><h4 id="编辑智能体操作" tabindex="-1"><a class="header-anchor" href="#编辑智能体操作"><span>编辑智能体操作</span></a></h4><p>这是一个更高级的交互模式。在这种交互模式中，人类实际上可以编辑智能体之前的一些决策。这可以在流程中（在断点之后，作为审批流程的一部分）或事后（作为时间旅行的一部分）进行</p><h4 id="时间旅行" tabindex="-1"><a class="header-anchor" href="#时间旅行"><span>时间旅行</span></a></h4><p>这是一个相当高级的交互模式。在这种交互模式中，人类可以回顾之前检查点的列表，找到他们喜欢的一个，选择性地编辑它，然后从那里恢复执行。状态回溯</p><h3 id="map-reduce-mapreduceexample-ipynb" tabindex="-1"><a class="header-anchor" href="#map-reduce-mapreduceexample-ipynb"><span>Map-Reduce (MapReduceExample.ipynb)</span></a></h3><p>在智能体中，一个常见的模式是生成一个对象列表，对每个对象进行一些处理，然后合并结果。这非常类似于常见的map-reduce操作。这可能会有一些棘手的地方。首先，提前定义一个结构化图可能很难，因为对象列表的长度可能是未知的。其次，为了进行这种map-reduce，你需要存在多个版本的状态……但图共享一个共同的状态，那么该如何实现呢？LangGraph通过Send API支持这一点。这可以用于允许条件边缘向多个节点发送多个不同的状态。它发送的状态可以与核心图的状态不同。 <img src="https://cdn.vistazx1.top/images/202409290951916.webp" alt="Pasted image 20240802113650"></p><h2 id="多智能体-multiagent-ipynb" tabindex="-1"><a class="header-anchor" href="#多智能体-multiagent-ipynb"><span>多智能体 (MultiAgent.ipynb)</span></a></h2><p>你可能听说过&quot;多智能体&quot;架构。这到底是什么意思？当大多数人谈论多智能体架构时，他们通常指的是一个系统，其中有多个不同的基于LLM的系统。这些基于LLM的系统可以简单到只是一个提示和一个LLM调用，或者复杂到像ReAct智能体一样。多智能体系统中的大问题是它们如何通信。这涉及到它们通信的模式以及它们通信的顺序。 LangGraph非常适合编排这些类型的系统。它允许你定义多个智能体（每个智能体是一个节点），一个任意状态（以封装它们通信的模式），以及边缘（以控制它们通信的顺序）。 <img src="https://cdn.vistazx1.top/images/202409290951917.webp" alt="Pasted image 20240802114831"></p><img src="https://www.plantuml.com/plantuml/svg/XLDTJnD157sVNt6T9ts0X5SI3QGGGYAODFfCDknWcooxoUuINxjgqmKh7xese4LQJB74O4iahRGH_WntPlild7RQRRiD-hOpS-wvvvvxTivnDTlTsZJ80vrjf4q6oSN4y_dLfQUBi6veZXFTBopFhpnRNG0zhMrQfax844X5KEL-auBcm0k7sMDFfK2SD_3WiFUQP0xJxFNKE0Q_t8JbgWXEkB-FHzKUCf6IkjQMcCbipRN6u67zZMo8pGfcLS-4PXXhhcKPP22IXisQ22u7P4bhovKjILSSJEdMAtFgIVyIPY6y-OZPocntZAw2y3Q7ksryx-7rLUVmbh_RveKQxfJm-XSUvtWzuB_FnUUtIZGbVPg8DPfGCkFPQ_wrA7OQFECzfhXtqCbuOIPBGG97d8bpn6R_7r7SlWcwWJqH4UR-y4_ryFI7ifACY9vqfmS1olUBukgKWge5xXTavvzvsPEIkE094jxmkLSZGoNt8MBIUmjJ6ygrv8PuCIFQlhW8UDcdX9YMoy1ElqovO6sCXWjWPXewPmNC-ieiqJwA_2RCrA5REa6WOW9zbyBQ1UvLvF4XdhJkMhig9_WXh-GykfSddbt9SDV-9aeUt_uUblF_A8o2332Qyc71dFoIV-jV" alt=""><h2 id="规划" tabindex="-1"><a class="header-anchor" href="#规划"><span>规划</span></a></h2><p>智能体系统面临的一个大问题是长期规划。克服这一问题的一个常见技术是有一个明确的规划步骤。这通常涉及调用LLM来提出一系列要执行的步骤。从那里，系统尝试执行这一系列任务（这可以使用子智能体来完成）。可选地，你可以在每一步之后重新审视计划，并在需要时更新它。 <img src="https://cdn.vistazx1.top/images/202409290951918.webp" alt="Pasted image 20240802114242"></p><img src="https://www.plantuml.com/plantuml/svg/ZP9DIm916CVlyoacxoxqTkaGnY8HH0VfBbEEiZIjuipIjHSeavH8Ax8ef43fa4MHuMAVnfdTlaNZpAvkUkdwFB_VCy__OHAKeI9pTWcOoU2iPMEOIfgRAnkhwqcuJH2bexgvbZ97HS0iHZ3qNvgyT37ugehJbjyy0o20ObwzBKhT64GKEXGNmNXeJ3kgLI38ZhO6hilBidljDziAO8Zkf8b5MPJYbKiDYfkUVzGVz6kAfPQT8pYj59J3zX_dvwGYhbuZJnVnvEFy-zchTlpM8pz-r_CLIFBv0W33432UoU_PyMMrDbo2imRKCVrELxmT0bKEcT7c4fmRWW-YTAx7Wd4lfATsbzQy0VLL0skQ2UtXYb9OaCBjXuof1S-jYVixh_mfzW-0Ga9UPvV6ufO1evUHEdzg1Ey5LDmfJCJvbqLmbabFtKqgo82yLk6zkhuOI60x8p_TBm00" alt=""><h2 id="反思" tabindex="-1"><a class="header-anchor" href="#反思"><span>反思</span></a></h2><p>智能体通常难以产生可靠的结果。因此，检查智能体是否正确完成任务是有帮助的。如果完成了——那么你可以结束。如果没有——那么你可以将为什么不正确的反馈传递回智能体的另一个迭代中。这个&quot;反思&quot;步骤通常使用LLM，但不是必须的。例如直接执行 llm 生成的代码，并且把执行结果反馈给 llm，这个也是一种反思。 <img src="https://cdn.vistazx1.top/images/202409290951919.webp" alt="Pasted image 20240802114139"></p><h2 id="react智能体" tabindex="-1"><a class="header-anchor" href="#react智能体"><span>ReAct智能体</span></a></h2><p>最常见的智能体架构之一是通常称为ReAct智能体架构的架构。在这种架构中，LLM在一个while循环中被反复调用。在每一步，智能体决定调用哪些工具，以及这些工具的输入应该是什么。然后执行这些工具，并将输出作为观察结果反馈给LLM。当智能体决定不再值得调用更多工具时，while循环终止。这是我们在LangGraph中预构建的少数高级智能体之一——你可以使用<code>create_react_agent</code>来使用它。</p><ul><li>使用工具调用让LLM调用工具</li><li>我们使用消息来提示LLM</li><li>允许使用需要多个输入的工具。</li><li>允许一次调用多个工具。</li><li>要求LLM在决定调用哪些工具之前显式生成一个&quot;思考&quot;步骤。这是&quot;ReAct&quot;中的&quot;推理&quot;部分。我们的实现默认不这样做，主要是因为LLM已经变得更好，这不再那么必要。当然，如果你希望提示它这样做，你完全可以。</li></ul><img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuL9CIKtBp4jL279r3d7qS_TnLKZEIImkvk922FZu-2fKSoa0WRR2qxRDJzVDUh6X-VcK5K-tBttQkbr34oQrfENvXBONovkUhf__VFVaP_Fc0ALgaGs2Q82RzQnp-Ok5FHelzar-sheKJIcoCGZB-tjVBkjuldicq4NePWUbEYQNF9kvwqNptYTx9yEr91Ub9fQanWF9v9BunFJKl1AeHbJbkdPWNrefb6TavgG-tRVgUTzwBf08K0BgQYketv_kt8RiVIweD50XYfkjeDu3ATy_vUdiUI1ljk_YGb44jnRYCsGvcEre3WKgNTO4b7woe_TfM-_BEGqlbZKYE-TfnypdkpkUhLq4zOD3QbuAC9e1" alt="">',45)]))}const c=a(r,[["render",i]]),l=JSON.parse('{"path":"/posts/2024-08-05-LangGraph%20%E4%BB%8B%E7%BB%8D.html","title":"LangGraph智能体框架介绍","lang":"zh-CN","frontmatter":{"title":"LangGraph智能体框架介绍","date":"2024-08-05T00:00:00.000Z","category":["人工智能","智能体框架","大语言模型"],"tag":["LangGraph","LLM","智能体架构","人机协作","流式处理","记忆管理","工具调用","多智能体","ReAct智能体","规划与执行","状态管理","循环控制","持久化","LangChain","智能体设计模式"],"excerpt":"LangGraph是一个用于构建有状态多参与者智能体应用的框架，与其他LLM框架相比具有循环、可控性和持久性三大核心优势。本文详细介绍其核心概念、设计模式和应用场景。","description":"Quick start: https://langchain-ai.github.io/langgraph/tutorials/introduction/ 什么是智能体？ 当我们谈论系统是\\"智能体\\"时，我们指的是使用大型语言模型（LLM）来决定控制流的系统。LLM 可以在不同层次上决定控制流，例如LLM在两个流程之间进行路由、LLM决定调用哪个工具、L...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"LangGraph智能体框架介绍\\",\\"image\\":[\\"https://cdn.vistazx1.top/images/202409290951953.webp\\",\\"https://cdn.vistazx1.top/images/202409290951915.webp\\",\\"https://cdn.vistazx1.top/images/202409290951916.webp\\",\\"https://cdn.vistazx1.top/images/202409290951917.webp\\",\\"https://cdn.vistazx1.top/images/202409290951918.webp\\",\\"https://cdn.vistazx1.top/images/202409290951919.webp\\"],\\"datePublished\\":\\"2024-08-05T00:00:00.000Z\\",\\"dateModified\\":\\"2025-05-29T14:36:19.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Guohao\\",\\"url\\":\\"https://space.vistazx1.top\\"}]}"],["meta",{"property":"og:url","content":"https://space.vistazx1.top/posts/2024-08-05-LangGraph%20%E4%BB%8B%E7%BB%8D.html"}],["meta",{"property":"og:site_name","content":"Vista"}],["meta",{"property":"og:title","content":"LangGraph智能体框架介绍"}],["meta",{"property":"og:description","content":"Quick start: https://langchain-ai.github.io/langgraph/tutorials/introduction/ 什么是智能体？ 当我们谈论系统是\\"智能体\\"时，我们指的是使用大型语言模型（LLM）来决定控制流的系统。LLM 可以在不同层次上决定控制流，例如LLM在两个流程之间进行路由、LLM决定调用哪个工具、L..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.vistazx1.top/images/202409290951953.webp"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-29T14:36:19.000Z"}],["meta",{"property":"article:tag","content":"智能体设计模式"}],["meta",{"property":"article:tag","content":"LangChain"}],["meta",{"property":"article:tag","content":"持久化"}],["meta",{"property":"article:tag","content":"循环控制"}],["meta",{"property":"article:tag","content":"状态管理"}],["meta",{"property":"article:tag","content":"规划与执行"}],["meta",{"property":"article:tag","content":"ReAct智能体"}],["meta",{"property":"article:tag","content":"多智能体"}],["meta",{"property":"article:tag","content":"工具调用"}],["meta",{"property":"article:tag","content":"记忆管理"}],["meta",{"property":"article:tag","content":"流式处理"}],["meta",{"property":"article:tag","content":"人机协作"}],["meta",{"property":"article:tag","content":"智能体架构"}],["meta",{"property":"article:tag","content":"LLM"}],["meta",{"property":"article:tag","content":"LangGraph"}],["meta",{"property":"article:published_time","content":"2024-08-05T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-05-29T14:36:19.000Z"}]]},"git":{"createdTime":1727667304000,"updatedTime":1748529379000,"contributors":[{"name":"root","username":"root","email":"root@vistazx1.top","commits":1,"url":"https://github.com/root"},{"name":"VvvvvGH","username":"VvvvvGH","email":"cheng123xp@gmail.com","commits":1,"url":"https://github.com/VvvvvGH"}]},"readingTime":{"minutes":10.37,"words":3112},"filePathRelative":"posts/2024-08-05-LangGraph 介绍.md","autoDesc":true}');export{c as comp,l as data};
